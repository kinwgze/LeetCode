//上来就是递归，然后就是超出时间限制...

/*
斐波那契数列的定义是 f(n+1)=f(n)+f(n−1) ，生成第 nn 项的做法有以下几种：

递归法：
原理： 把 f(n) 问题的计算拆分成f(n−1) 和 f(n−2) 两个子问题的计算，并递归，以f(0) 和 f(1) 为终止条件。
缺点： 大量重复的递归计算，例如 f(n) 和 f(n−1) 两者向下递归需要 各自计算 f(n−2) 的值。

记忆化递归法：
原理： 在递归法的基础上，新建一个长度为 nn 的数组，用于在递归时存储 f(0) 至 f(n) 的数字值，
重复遇到某数字则直接从数组取用，避免了重复的递归计算。
缺点： 记忆化存储需要使用 O(N) 的额外空间。

动态规划：
原理： 以斐波那契数列性质 f(n+1)=f(n)+f(n−1) 为转移方程。
从计算效率、空间复杂度上看，动态规划是本题的最佳解法。
*/

/*
动态规划解析：
状态定义： 设dp 为一维数组，其中 dp[i]的值代表 斐波那契数列第 i个数字 。
转移方程： dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义f(n+1)=f(n)+f(n−1) ；
初始状态： dp[0]=0, dp[1]=1 ，即初始化前两个数字；
返回值： dp[n] ，即斐波那契数列的第 n 个数字。
*/

class Solution {
    public int fib(int n) {
        int a = 0, b = 1, sum;
        for (int i = 0; i < n; i ++) {
            sum = (a + b) % 1000000007;
            a = b;
            b = sum;
        }
        return a;
    }
}